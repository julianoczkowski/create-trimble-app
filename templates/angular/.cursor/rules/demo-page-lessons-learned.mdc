---
description: Lessons learned from creating demo pages - what to do and what NOT to do. Covers event handling, signals, component usage patterns, and common pitfalls.
globs: ["**/demos/**/*.ts", "**/demos/**/*.html"]
---

# Demo Page Development - Lessons Learned

Critical lessons learned from creating multiple demo pages. **What works, what doesn't, and why.**

---

## ‚ö†Ô∏è CRITICAL: Event Handling Patterns

### ‚úÖ DO: Use `$event` Directly for Output Events

**Angular automatically unwraps `CustomEvent` for output events.** In the template, use `$event` directly:

```typescript
// ‚úÖ CORRECT: Template uses $event directly
<modus-text-input
  [value]="textValue()"
  (inputChange)="handleTextChange($event)"
/>

// ‚úÖ CORRECT: Handler receives unwrapped InputEvent
handleTextChange(event: InputEvent): void {
  const target = event.target as HTMLInputElement;
  this.textValue.set(target.value);
}
```

### ‚ùå DON'T: Use `$event.detail` in Templates

**This will cause TypeScript compilation errors:**

```typescript
// ‚ùå WRONG: TypeScript error - $event.detail is not needed
<modus-text-input
  [value]="textValue()"
  (inputChange)="handleTextChange($event.detail)"  // ‚ùå Compilation error
/>
```

**Why**: Angular's output events automatically unwrap `CustomEvent<T>` to `T` before passing to your handler.

### ‚úÖ DO: Check Component Wrapper for Event Types

**Different components emit different event types.** Always check the component wrapper:

```typescript
// From modus-text-input.component.ts
readonly inputChange = output<InputEvent>();

// From modus-time-input.component.ts  
readonly inputChange = output<Event>();  // Different type!

// From modus-rating.component.ts
readonly ratingChange = output<IRatingChange>();  // Custom interface!
```

**Rule**: **Always check the component wrapper's `output<T>()` type before writing handlers.**

### ‚úÖ DO: Match Handler Parameter Type to Component Output

```typescript
// ‚úÖ CORRECT: Text input emits InputEvent
handleTextChange(event: InputEvent): void {
  const target = event.target as HTMLInputElement;
  // ...
}

// ‚úÖ CORRECT: Time input emits Event
handleTimeChange(event: Event): void {
  const target = event.target as HTMLInputElement;
  // ...
}

// ‚úÖ CORRECT: Rating emits custom interface
handleRatingChange(event: IRatingChange): void {
  this.ratingValue.set(event.value);
  // ...
}
```

### ‚ùå DON'T: Assume All Components Use InputEvent

```typescript
// ‚ùå WRONG: Time input uses Event, not InputEvent
handleTimeChange(event: InputEvent): void {  // ‚ùå Type mismatch!
  // ...
}

// ‚ùå WRONG: Rating uses IRatingChange, not InputEvent
handleRatingChange(event: InputEvent): void {  // ‚ùå Type mismatch!
  // ...
}
```

---

## ‚ö†Ô∏è CRITICAL: Signal Usage in Templates

### ‚úÖ DO: Call Signals as Functions in Templates

**Signals are functions and must be called with `()` in templates:**

```typescript
// ‚úÖ CORRECT: Signal called as function
export class DemoComponent {
  readonly value = signal<string>('');
  
  // In template:
  [value]="value()"  // ‚úÖ Must call with ()
  @if (value()) {    // ‚úÖ Must call with ()
    <div>{{ value() }}</div>  // ‚úÖ Must call with ()
  }
}
```

### ‚ùå DON'T: Access Signal Properties Directly

```typescript
// ‚ùå WRONG: Signal is a function, not an object
export class DemoComponent {
  readonly value = signal<string>('');
  
  // In template:
  [value]="value"     // ‚ùå WRONG: Missing ()
  @if (value) {       // ‚ùå WRONG: Missing ()
    <div>{{ value }}</div>  // ‚ùå WRONG: Missing ()
  }
}
```

### ‚úÖ DO: Use Signals for Reactive State

```typescript
// ‚úÖ CORRECT: Use signals for two-way binding
export class InteractiveDemo {
  readonly sliderValue = signal<number>(50);
  
  handleSliderChange(event: InputEvent): void {
    const target = event.target as HTMLInputElement;
    this.sliderValue.set(parseInt(target.value, 10));
  }
}

// In template:
<modus-slider
  [value]="sliderValue()"
  (inputChange)="handleSliderChange($event)"
/>
<div>Value: {{ sliderValue() }}</div>
```

### ‚ùå DON'T: Use Class Properties for Reactive State

```typescript
// ‚ùå WRONG: Not reactive, won't update template
export class InteractiveDemo {
  sliderValue: number = 50;  // ‚ùå Not reactive
  
  handleSliderChange(event: InputEvent): void {
    const target = event.target as HTMLInputElement;
    this.sliderValue = parseInt(target.value, 10);  // ‚ùå Template won't update
  }
}
```

---

## ‚ö†Ô∏è CRITICAL: Signal Object Access

### ‚úÖ DO: Call Signal Function for Object Properties

**When a signal contains an object, access properties AFTER calling the signal:**

```typescript
// ‚úÖ CORRECT: Signal contains object
export class PaginationDemo {
  readonly paginationState = signal<{ page: number; count: number }>({
    page: 2,
    count: 8,
  });
  
  // In template:
  [page]="paginationState().page"      // ‚úÖ Call signal, then access property
  [count]="paginationState().count"    // ‚úÖ Call signal, then access property
  <div>{{ paginationState().page }} / {{ paginationState().count }}</div>
}
```

### ‚ùå DON'T: Access Signal Object Properties Directly

```typescript
// ‚ùå WRONG: Can't access properties without calling signal first
export class PaginationDemo {
  readonly paginationState = signal<{ page: number; count: number }>({
    page: 2,
    count: 8,
  });
  
  // In template:
  [page]="paginationState.page"       // ‚ùå WRONG: paginationState is a function
  [count]="paginationState.count"      // ‚ùå WRONG: Must call signal first
  <div>{{ paginationState.page }}</div>  // ‚ùå WRONG: TypeScript error
}
```

**Error you'll see**: `Property 'page' does not exist on type 'WritableSignal<{ page: number; count: number }>'.`

---

## ‚ö†Ô∏è Component-Specific Patterns

### ‚úÖ DO: Check Component Documentation

**Each component has unique patterns. Check the wrapper component:**

```typescript
// ‚úÖ CORRECT: Check modus-rating.component.ts
// Shows it emits IRatingChange, not InputEvent
handleRatingChange(event: IRatingChange): void {
  this.ratingValue.set(event.value);
}
```

### ‚úÖ DO: Check Component Output Types

**Before writing event handlers, check the component wrapper:**

```bash
# ‚úÖ DO: Read component wrapper to understand event types
cat src/app/components/modus-[component].component.ts | grep "output<"
```

### ‚ùå DON'T: Assume All Components Use Same Event Pattern

```typescript
// ‚ùå WRONG: Assuming all use InputEvent
handleChange(event: InputEvent): void {  // ‚ùå Wrong for rating, time-input, etc.
  // ...
}
```

---

## ‚ö†Ô∏è Icon Name Validation

### ‚úÖ DO: Always Validate Icon Names

**Before using any icon, validate it exists:**

```bash
# ‚úÖ DO: Run icon validation
npm run lint:icon-names
```

### ‚ùå DON'T: Use Non-Existent Icon Names

```typescript
// ‚ùå WRONG: 'print' doesn't exist
<modus-button icon="print" />  // ‚ùå Error: Did you mean 'printer'?

// ‚úÖ CORRECT: Use 'printer'
<modus-button icon="printer" />
```

**Common replacements**:
- `print` ‚Üí `printer`
- `error` ‚Üí `alert`
- `edit` ‚Üí `file_edit`
- `user` ‚Üí `user_account`

### ‚úÖ DO: Check Icon Suggestions from Linter

**When linter fails, it provides suggestions:**

```
Invalid Modus icon name: print
Did you mean: printer, pin
Similar icons: printer, footprints
```

**Always use the suggestions provided by the linter.**

---

## ‚ö†Ô∏è Component Color Types

### ‚úÖ DO: Check Component-Specific Color Types

**Each component has different valid colors. Check the component wrapper:**

```typescript
// From modus-button.component.ts
type ButtonColor = 'primary' | 'secondary' | 'tertiary' | 'warning' | 'danger';

// From modus-loader.component.ts  
type LoaderColor = 'primary' | 'success' | 'warning' | 'error' | undefined;
```

**Note**: Button uses `'danger'`, but Loader uses `'error'`. **They're different!**

### ‚ùå DON'T: Assume Colors Are Universal

```typescript
// ‚ùå WRONG: 'danger' doesn't exist for loader
<modus-loader color="danger" />  // ‚ùå TypeScript error

// ‚úÖ CORRECT: Use 'error' for loader
<modus-loader color="error" />
```

### ‚úÖ DO: Read Component Wrapper Type Definitions

```typescript
// ‚úÖ DO: Check component wrapper for valid colors
// File: src/app/components/modus-[component].component.ts
// Look for: readonly color = input<[Component]Color | undefined>();
```

---

## ‚ö†Ô∏è Import Management

### ‚úÖ DO: Only Import Used Components

**Remove unused imports to avoid build warnings:**

```typescript
// ‚úÖ CORRECT: Only import what's used
@Component({
  imports: [
    CommonModule,
    DemoPageComponent,
    DemoExampleComponent,
    ModusTextInputComponent,  // ‚úÖ Actually used in template
    ModusInputLabelComponent, // ‚úÖ Actually used in template
  ],
})
```

### ‚ùå DON'T: Leave Unused Imports

```typescript
// ‚ùå WRONG: Unused imports cause build warnings
@Component({
  imports: [
    CommonModule,
    ModusButtonComponent,  // ‚ùå Not used anywhere - remove it
    ModusCardComponent,   // ‚ùå Not used anywhere - remove it
  ],
})
```

### ‚úÖ DO: Run Build to Catch Unused Imports

```bash
# ‚úÖ DO: Run build to find unused imports
npm run build
```

---

## ‚ö†Ô∏è Registration Requirements

### ‚úÖ DO: Register in Three Places

**Every demo page must be registered in three locations:**

1. **Route registration** (`app.routes.ts`):
```typescript
{
  path: 'demos/select',
  loadComponent: () =>
    import('./components/demos/select-demo-page.component').then(
      (m) => m.SelectDemoPageComponent
    ),
}
```

2. **Export registration** (`demos/index.ts`):
```typescript
export * from './select-demo-page.component';
```

3. **Demo link registration** (`demos-page.component.ts`):
```html
<a
  routerLink="/demos/select"
  class="p-4 rounded-lg bg-card border-default hover:bg-muted transition-colors"
>
  <div class="text-lg font-medium text-card-foreground mb-1">Select</div>
  <div class="text-sm text-muted-foreground">
    Dropdown menu for choosing from a list of options
  </div>
</a>
```

### ‚ùå DON'T: Skip Any Registration Step

**Missing any step will cause:**
- Route not accessible (missing route)
- Import errors (missing export)
- Demo not discoverable (missing link)

---

## ‚ö†Ô∏è Template Patterns

### ‚úÖ DO: Use Modus Button for Actions

**Use Modus components, not native HTML:**

```html
<!-- ‚úÖ CORRECT: Use Modus button -->
<modus-button color="primary" size="sm" (buttonClick)="handleClick()">
  Click Me
</modus-button>
```

### ‚ùå DON'T: Use Native HTML Elements

```html
<!-- ‚ùå WRONG: Use native button -->
<button class="px-4 py-2 rounded-lg bg-primary" (click)="handleClick()">
  Click Me
</button>
```

**Rule**: **Always prefer Modus components over native HTML elements.**

---

## ‚ö†Ô∏è Validation Checklist

### ‚úÖ DO: Run Full Validation Before Completion

**Before completing any demo page, verify ALL of these:**

- [ ] **Event handlers**: Use `$event` directly, check component output type
- [ ] **Signals**: Call with `()` in templates, use `.set()` for updates
- [ ] **Signal objects**: Call signal function before accessing properties
- [ ] **Icon names**: Run `npm run lint:icon-names` - all pass
- [ ] **Component colors**: Check component's TypeScript definition
- [ ] **Imports**: Run `npm run build` - no unused import warnings
- [ ] **Routes**: Added to `app.routes.ts`
- [ ] **Exports**: Added to `demos/index.ts`
- [ ] **Links**: Added to `demos-page.component.ts` in correct category
- [ ] **Linting**: Run `npm run lint:all` - all checks pass
- [ ] **Build**: Run `npm run build` - no errors

---

## üîç Debugging Event Handling Issues

### Issue: TypeScript Error "Argument of type 'X' is not assignable"

**Symptom**:
```
TS2345: Argument of type 'number' is not assignable to parameter of type 'InputEvent'.
```

**Solution**:
1. Check component wrapper's `output<T>()` type
2. Use `$event` directly (not `$event.detail`)
3. Match handler parameter type to component output type

**Example**:
```typescript
// Component emits: output<InputEvent>()
// ‚úÖ CORRECT:
<inputChange)="handleChange($event)"
handleChange(event: InputEvent): void { ... }

// ‚ùå WRONG:
<inputChange)="handleChange($event.detail)"
```

### Issue: Signal Not Updating Template

**Symptom**: Template doesn't update when signal changes.

**Solution**:
1. Ensure signal is called with `()` in template
2. Use `.set()` or `.update()` to modify signal value
3. Don't reassign signal (signals are immutable)

**Example**:
```typescript
// ‚úÖ CORRECT:
readonly value = signal<string>('');
this.value.set('new value');  // Updates template

// ‚ùå WRONG:
readonly value = signal<string>('');
this.value = signal('new value');  // Doesn't work - signals are immutable
```

### Issue: "Property does not exist on type WritableSignal"

**Symptom**:
```
TS2339: Property 'page' does not exist on type 'WritableSignal<{ page: number; count: number }>'.
```

**Solution**: Call signal function before accessing properties:

```typescript
// ‚úÖ CORRECT:
paginationState().page  // Call signal first, then access property

// ‚ùå WRONG:
paginationState.page    // Can't access property of function
```

---

## üìö Reference Patterns

### ‚úÖ Working Event Handler Pattern

```typescript
// 1. Check component wrapper output type
// modus-text-input.component.ts: output<InputEvent>()

// 2. Use $event directly in template
<modus-text-input
  [value]="textValue()"
  (inputChange)="handleTextChange($event)"
/>

// 3. Handler receives unwrapped event type
handleTextChange(event: InputEvent): void {
  const target = event.target as HTMLInputElement;
  this.textValue.set(target.value);
}
```

### ‚úÖ Working Signal Pattern

```typescript
// 1. Define signal with type
readonly value = signal<string>('');

// 2. Use in template with () call
<input [value]="value()" />
@if (value()) {
  <div>{{ value() }}</div>
}

// 3. Update with .set() or .update()
handleChange(event: InputEvent): void {
  const target = event.target as HTMLInputElement;
  this.value.set(target.value);  // Updates template automatically
}
```

### ‚úÖ Working Signal Object Pattern

```typescript
// 1. Define signal with object type
readonly state = signal<{ page: number; count: number }>({
  page: 2,
  count: 8,
});

// 2. Access properties AFTER calling signal
<div>Page: {{ state().page }} / {{ state().count }}</div>
<modus-pagination
  [page]="state().page"
  [count]="state().count"
/>

// 3. Update with .update() for object mutation
handlePageChange(change: IPageChange): void {
  this.state.update((current) => ({
    ...current,
    page: change.newPage,
  }));
}
```

---

## üéØ Key Takeaways

1. **Event Handling**: Use `$event` directly, not `$event.detail`. Check component output type.
2. **Signals**: Always call with `()` in templates. Use `.set()` or `.update()` for changes.
3. **Signal Objects**: Call signal function before accessing properties: `signal().property`
4. **Icons**: Always validate with `npm run lint:icon-names`
5. **Colors**: Check component-specific color types, not universal
6. **Imports**: Remove unused imports to avoid build warnings
7. **Registration**: Always register in three places: routes, exports, demo links
8. **Validation**: Run `npm run lint:all` and `npm run build` before completion

---

## üö® Common Mistakes to Avoid

1. ‚ùå Using `$event.detail` in templates ‚Üí Use `$event` directly
2. ‚ùå Forgetting `()` when calling signals ‚Üí Always use `value()`
3. ‚ùå Accessing signal object properties without calling function ‚Üí Use `signal().property`
4. ‚ùå Assuming all components use `InputEvent` ‚Üí Check component output type
5. ‚ùå Using invalid icon names ‚Üí Always validate with linter
6. ‚ùå Assuming colors are universal ‚Üí Check component-specific types
7. ‚ùå Leaving unused imports ‚Üí Remove to avoid build warnings
8. ‚ùå Skipping registration steps ‚Üí Register in all three places

---

**Remember**: When in doubt, check existing working demo pages in `src/app/components/demos/` for reference patterns!
