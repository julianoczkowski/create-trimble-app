---
alwaysApply: true
---

# Navbar Usage Rules

Comprehensive guide for using the Modus Navbar component in Angular, covering search expansion, button visibility, event handling, and state management.

---

## ‚ö†Ô∏è CRITICAL: Search Input Expansion

### ‚úÖ DO: Set Both `search` and `searchInput` in Visibility

**For search to expand, you MUST set both visibility flags:**

```typescript
// ‚úÖ CORRECT: Both flags required for search expansion
<modus-navbar
  [userCard]="userCard"
  [visibility]="{ user: true, search: true, searchInput: true }"
  [searchInputOpen]="searchInputOpen()"
  (searchClick)="handleSearchClick($event)"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
/>
```

**Why**:

- `search: true` shows the search button
- `searchInput: true` makes the search input field visible when expanded

### ‚ùå DON'T: Forget `searchInput` in Visibility

```typescript
// ‚ùå WRONG: Missing searchInput: true - search won't expand!
<modus-navbar
  [userCard]="userCard"
  [visibility]="{ user: true, search: true }"  // ‚ùå Missing searchInput: true
  [searchInputOpen]="searchInputOpen()"
/>
```

**Result**: The search button appears, but clicking it won't expand the search input because the input field isn't visible.

### ‚úÖ DO: Two-Way Bind Search State

**Always bind `[searchInputOpen]` and handle `(searchInputOpenChange)`:**

```typescript
// ‚úÖ CORRECT: Two-way binding with state sync
readonly searchInputOpen = signal<boolean>(false);

// In template:
<modus-navbar
  [searchInputOpen]="searchInputOpen()"
  (searchClick)="handleSearchClick($event)"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
/>

// In component:
handleSearchClick(event: MouseEvent | KeyboardEvent): void {
  // Toggle the search input state when search button is clicked
  this.searchInputOpen.set(!this.searchInputOpen());
}

handleSearchInputOpenChange(event: boolean): void {
  // Sync state with navbar (in case navbar manages state internally)
  if (this.searchInputOpen() !== event) {
    this.searchInputOpen.set(event);
  }
}
```

**Why**: This ensures your component state stays synchronized with the navbar's internal state.

### ‚ùå DON'T: Only Handle One Event

```typescript
// ‚ùå WRONG: Missing searchInputOpenChange handler
<modus-navbar
  [searchInputOpen]="searchInputOpen()"
  (searchClick)="handleSearchClick($event)"
  // ‚ùå Missing (searchInputOpenChange) - state might get out of sync
/>

// ‚ùå ALSO WRONG: Only listening to state change without handling click
<modus-navbar
  [searchInputOpen]="searchInputOpen()"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
  // ‚ùå Missing (searchClick) - manual toggle won't work
/>
```

---

## ‚ö†Ô∏è Button Visibility Patterns

### ‚úÖ DO: Set Visibility for Each Button

**Each button must be explicitly enabled in the `visibility` object:**

```typescript
// ‚úÖ CORRECT: Explicit visibility for all buttons you want to show
<modus-navbar
  [userCard]="userCard"
  [visibility]="{
    user: true,           // User profile button
    search: true,         // Search button
    searchInput: true,    // Search input field (required with search: true)
    help: true,           // Help button
    apps: true,           // Apps menu button
    notifications: true,  // Notifications button
    mainMenu: true       // Main menu button
  }"
/>
```

### ‚ùå DON'T: Assume Buttons Are Visible by Default

```typescript
// ‚ùå WRONG: Buttons are hidden by default
<modus-navbar [userCard]="userCard" />
// Only 'user' button is visible by default (user: true in defaults)
// All other buttons (search, help, apps, etc.) are hidden!

// ‚ùå ALSO WRONG: Partial visibility object doesn't override defaults
<modus-navbar
  [userCard]="userCard"
  [visibility]="{ search: true }"  // ‚ùå Other buttons still use defaults
/>
// This will show search button but hide user button (because user defaults to true, but we didn't include it)
```

### ‚úÖ DO: Check Default Visibility Settings

**The navbar component has default visibility settings:**

```typescript
// Default visibility from modus-navbar.component.ts:
readonly visibility = input<INavbarVisibility | undefined>({
  ai: false,
  apps: false,
  help: false,
  mainMenu: false,
  notifications: false,
  search: false,        // Hidden by default
  searchInput: false,   // Hidden by default
  user: true,           // Visible by default
});
```

**Rule**: **Always explicitly set all buttons you want visible in the `visibility` object.**

---

## ‚ö†Ô∏è Event Handling Patterns

### ‚úÖ DO: Handle Events with Correct Types

**Each navbar event emits a specific type. Match handler parameter types:**

```typescript
// ‚úÖ CORRECT: Button click events
handleSearchClick(event: MouseEvent | KeyboardEvent): void {
  this.searchInputOpen.set(!this.searchInputOpen());
}

handleHelpClick(event: MouseEvent | KeyboardEvent): void {
  console.log('Help clicked', event);
}

handleAppsClick(event: MouseEvent | KeyboardEvent): void {
  console.log('Apps clicked', event);
}

handleNotificationsClick(event: MouseEvent | KeyboardEvent): void {
  console.log('Notifications clicked', event);
}

// ‚úÖ CORRECT: Menu open state change events
handleMainMenuOpenChange(event: boolean): void {
  this.mainMenuOpen.set(event);
}

handleNotificationsMenuOpenChange(event: boolean): void {
  this.notificationsMenuOpen.set(event);
}

handleAppsMenuOpenChange(event: boolean): void {
  this.appsMenuOpen.set(event);
}

// ‚úÖ CORRECT: Search value change event
handleSearchChange(event: { value: string }): void {
  this.lastSearch.set(event.value);
}
```

### ‚ùå DON'T: Use Wrong Event Types

```typescript
// ‚ùå WRONG: Button click events are NOT InputEvent
handleSearchClick(event: InputEvent): void {  // ‚ùå Wrong type!
  // ...
}

// ‚ùå WRONG: Menu open events are NOT CustomEvent
handleMainMenuOpenChange(event: CustomEvent<boolean>): void {  // ‚ùå Wrong type!
  // Angular unwraps CustomEvent automatically - receive boolean directly
  // ...
}
```

---

## ‚ö†Ô∏è State Management Patterns

### ‚úÖ DO: Use Signals for Navbar State

**Use Angular signals for all navbar-related state:**

```typescript
export class NavbarComponent {
  // Search state
  readonly searchInputOpen = signal<boolean>(false);
  readonly lastSearch = signal<string>('');

  // Menu states
  readonly mainMenuOpen = signal<boolean>(false);
  readonly notificationsMenuOpen = signal<boolean>(false);
  readonly appsMenuOpen = signal<boolean>(false);

  // Tracking state
  readonly lastAction = signal<string>('');
}
```

**Why**: Signals provide reactive state management that works seamlessly with Angular's change detection.

### ‚ùå DON'T: Use Class Properties for State

```typescript
// ‚ùå WRONG: Not reactive, won't update template
export class NavbarComponent {
  searchInputOpen: boolean = false; // ‚ùå Not reactive
  mainMenuOpen: boolean = false; // ‚ùå Not reactive
}
```

### ‚úÖ DO: Two-Way Bind Menu States

**For menus with open/close states, bind both property and event:**

```typescript
// ‚úÖ CORRECT: Two-way binding for menu states
<modus-navbar
  [mainMenuOpen]="mainMenuOpen()"
  [notificationsMenuOpen]="notificationsMenuOpen()"
  [appsMenuOpen]="appsMenuOpen()"
  (mainMenuOpenChange)="handleMainMenuOpenChange($event)"
  (notificationsMenuOpenChange)="handleNotificationsMenuOpenChange($event)"
  (appsMenuOpenChange)="handleAppsMenuOpenChange($event)"
/>
```

### ‚ùå DON'T: Only Bind One Way

```typescript
// ‚ùå WRONG: Only binding property without event handler
<modus-navbar
  [mainMenuOpen]="mainMenuOpen()"
  // ‚ùå Missing (mainMenuOpenChange) - state won't sync when navbar controls it
/>

// ‚ùå ALSO WRONG: Only handling event without binding property
<modus-navbar
  (mainMenuOpenChange)="handleMainMenuOpenChange($event)"
  // ‚ùå Missing [mainMenuOpen] - can't control initial state
/>
```

---

## ‚ö†Ô∏è Complete Search Expansion Pattern

### ‚úÖ DO: Follow This Complete Pattern

**For search expansion to work correctly, use this complete pattern:**

```typescript
export class MyComponent {
  readonly userCard: INavbarUserCard = {
    name: 'John Doe',
    email: 'john.doe@example.com',
    avatarSrc: 'https://via.placeholder.com/64',
    avatarAlt: 'User avatar',
  };

  readonly searchInputOpen = signal<boolean>(false);
  readonly lastSearch = signal<string>('');

  handleSearchClick(event: MouseEvent | KeyboardEvent): void {
    // Toggle the search input state when search button is clicked
    this.searchInputOpen.set(!this.searchInputOpen());
  }

  handleSearchInputOpenChange(event: boolean): void {
    // Sync state with navbar (in case navbar manages state internally)
    if (this.searchInputOpen() !== event) {
      this.searchInputOpen.set(event);
    }
  }

  handleSearchChange(event: { value: string }): void {
    this.lastSearch.set(event.value);
  }
}
```

```html
<!-- ‚úÖ CORRECT: Complete search expansion pattern -->
<modus-navbar
  [userCard]="userCard"
  [visibility]="{
    user: true,
    search: true,      // ‚úÖ Required: Shows search button
    searchInput: true  // ‚úÖ Required: Makes input visible when expanded
  }"
  [searchInputOpen]="searchInputOpen()"
  (searchClick)="handleSearchClick($event)"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
  (searchChange)="handleSearchChange($event)"
/>
```

### ‚ùå DON'T: Skip Any Required Steps

```typescript
// ‚ùå WRONG: Missing searchInput in visibility
<modus-navbar
  [visibility]="{ user: true, search: true }"  // ‚ùå Missing searchInput: true
/>

// ‚ùå WRONG: Missing searchClick handler
<modus-navbar
  [searchInputOpen]="searchInputOpen()"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
  // ‚ùå Missing (searchClick) - button click won't toggle state
/>

// ‚ùå WRONG: Missing searchInputOpenChange handler
<modus-navbar
  [searchInputOpen]="searchInputOpen()"
  (searchClick)="handleSearchClick($event)"
  // ‚ùå Missing (searchInputOpenChange) - state might get out of sync
/>
```

---

## ‚ö†Ô∏è Button Event Patterns

### ‚úÖ DO: Handle Button Click Events

**All navbar buttons emit click events. Handle them appropriately:**

```typescript
// ‚úÖ CORRECT: Handle all button clicks
<modus-navbar
  [visibility]="{
    user: true,
    search: true,
    searchInput: true,
    help: true,
    apps: true,
    notifications: true,
    mainMenu: true
  }"
  (searchClick)="handleSearchClick($event)"
  (helpClick)="handleHelpClick($event)"
  (appsClick)="handleAppsClick($event)"
  (notificationsClick)="handleNotificationsClick($event)"
  (mainMenuOpenChange)="handleMainMenuOpenChange($event)"
/>
```

```typescript
// ‚úÖ CORRECT: Handler implementations
handleSearchClick(event: MouseEvent | KeyboardEvent): void {
  this.searchInputOpen.set(!this.searchInputOpen());
  this.lastAction.set('Search button clicked');
}

handleHelpClick(event: MouseEvent | KeyboardEvent): void {
  this.lastAction.set('Help button clicked');
  // Open help documentation, show help modal, etc.
}

handleAppsClick(event: MouseEvent | KeyboardEvent): void {
  this.lastAction.set('Apps button clicked');
  // Show apps menu, navigate to apps page, etc.
}

handleNotificationsClick(event: MouseEvent | KeyboardEvent): void {
  this.lastAction.set('Notifications button clicked');
  // Show notifications panel, etc.
}
```

### ‚ùå DON'T: Ignore Button Events

```typescript
// ‚ùå WRONG: Buttons have no handlers - no interactivity
<modus-navbar
  [visibility]="{ help: true, apps: true, notifications: true }"
  // ‚ùå No event handlers - buttons won't do anything when clicked
/>
```

---

## ‚ö†Ô∏è Menu State Patterns

### ‚úÖ DO: Manage Menu Open States

**Menus with open/close states need two-way binding:**

```typescript
// ‚úÖ CORRECT: Complete menu state management
export class NavbarComponent {
  readonly mainMenuOpen = signal<boolean>(false);
  readonly notificationsMenuOpen = signal<boolean>(false);
  readonly appsMenuOpen = signal<boolean>(false);

  handleMainMenuOpenChange(event: boolean): void {
    this.mainMenuOpen.set(event);
    this.lastAction.set(`Main menu ${event ? 'opened' : 'closed'}`);
  }

  handleNotificationsMenuOpenChange(event: boolean): void {
    this.notificationsMenuOpen.set(event);
    this.lastAction.set(`Notifications menu ${event ? 'opened' : 'closed'}`);
  }

  handleAppsMenuOpenChange(event: boolean): void {
    this.appsMenuOpen.set(event);
    this.lastAction.set(`Apps menu ${event ? 'opened' : 'closed'}`);
  }
}
```

```html
<!-- ‚úÖ CORRECT: Two-way binding for menu states -->
<modus-navbar
  [mainMenuOpen]="mainMenuOpen()"
  [notificationsMenuOpen]="notificationsMenuOpen()"
  [appsMenuOpen]="appsMenuOpen()"
  (mainMenuOpenChange)="handleMainMenuOpenChange($event)"
  (notificationsMenuOpenChange)="handleNotificationsMenuOpenChange($event)"
  (appsMenuOpenChange)="handleAppsMenuOpenChange($event)"
/>
```

### ‚ùå DON'T: Only Use One Direction

```typescript
// ‚ùå WRONG: Only controlling state, not listening to changes
<modus-navbar
  [mainMenuOpen]="mainMenuOpen()"
  // ‚ùå Missing event handler - can't react to navbar-controlled state changes
/>

// ‚ùå WRONG: Only listening to changes, not controlling state
<modus-navbar
  (mainMenuOpenChange)="handleMainMenuOpenChange($event)"
  // ‚ùå Missing property binding - can't set initial state
/>
```

---

## ‚ö†Ô∏è User Card Requirements

### ‚úÖ DO: Always Provide User Card

**The navbar requires a `userCard` input:**

```typescript
// ‚úÖ CORRECT: Provide user card data
readonly userCard: INavbarUserCard = {
  name: 'John Doe',
  email: 'john.doe@example.com',
  avatarSrc: 'https://via.placeholder.com/64',
  avatarAlt: 'User avatar',
};
```

```html
<!-- ‚úÖ CORRECT: Bind user card -->
<modus-navbar [userCard]="userCard" />
```

### ‚ùå DON'T: Omit User Card

```typescript
// ‚ùå WRONG: Missing required userCard
<modus-navbar />
// ‚ùå TypeScript error: Property 'userCard' is required
```

---

## ‚ö†Ô∏è Common Patterns

### Pattern 1: Basic Search Navbar

```typescript
// ‚úÖ CORRECT: Minimal search navbar
export class BasicNavbar {
  readonly userCard: INavbarUserCard = {
    name: 'John Doe',
    email: 'john.doe@example.com',
  };

  readonly searchInputOpen = signal<boolean>(false);

  handleSearchClick(event: MouseEvent | KeyboardEvent): void {
    this.searchInputOpen.set(!this.searchInputOpen());
  }

  handleSearchInputOpenChange(event: boolean): void {
    if (this.searchInputOpen() !== event) {
      this.searchInputOpen.set(event);
    }
  }
}
```

```html
<modus-navbar
  [userCard]="userCard"
  [visibility]="{ user: true, search: true, searchInput: true }"
  [searchInputOpen]="searchInputOpen()"
  (searchClick)="handleSearchClick($event)"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
/>
```

### Pattern 2: Full Featured Navbar

```typescript
// ‚úÖ CORRECT: Complete navbar with all features
export class FullNavbar {
  readonly userCard: INavbarUserCard = {
    /* ... */
  };

  readonly searchInputOpen = signal<boolean>(false);
  readonly mainMenuOpen = signal<boolean>(false);
  readonly notificationsMenuOpen = signal<boolean>(false);
  readonly appsMenuOpen = signal<boolean>(false);
  readonly lastSearch = signal<string>('');
  readonly lastAction = signal<string>('');

  // All handlers for search, buttons, and menus
  handleSearchClick(event: MouseEvent | KeyboardEvent): void {
    /* ... */
  }
  handleSearchInputOpenChange(event: boolean): void {
    /* ... */
  }
  handleSearchChange(event: { value: string }): void {
    /* ... */
  }
  handleHelpClick(event: MouseEvent | KeyboardEvent): void {
    /* ... */
  }
  handleAppsClick(event: MouseEvent | KeyboardEvent): void {
    /* ... */
  }
  handleNotificationsClick(event: MouseEvent | KeyboardEvent): void {
    /* ... */
  }
  handleMainMenuOpenChange(event: boolean): void {
    /* ... */
  }
  handleNotificationsMenuOpenChange(event: boolean): void {
    /* ... */
  }
  handleAppsMenuOpenChange(event: boolean): void {
    /* ... */
  }
}
```

```html
<modus-navbar
  [userCard]="userCard"
  [visibility]="{
    user: true,
    search: true,
    searchInput: true,
    help: true,
    apps: true,
    notifications: true,
    mainMenu: true
  }"
  [searchInputOpen]="searchInputOpen()"
  [mainMenuOpen]="mainMenuOpen()"
  [notificationsMenuOpen]="notificationsMenuOpen()"
  [appsMenuOpen]="appsMenuOpen()"
  (searchClick)="handleSearchClick($event)"
  (searchInputOpenChange)="handleSearchInputOpenChange($event)"
  (searchChange)="handleSearchChange($event)"
  (helpClick)="handleHelpClick($event)"
  (appsClick)="handleAppsClick($event)"
  (notificationsClick)="handleNotificationsClick($event)"
  (mainMenuOpenChange)="handleMainMenuOpenChange($event)"
  (notificationsMenuOpenChange)="handleNotificationsMenuOpenChange($event)"
  (appsMenuOpenChange)="handleAppsMenuOpenChange($event)"
/>
```

---

## ‚ö†Ô∏è Troubleshooting

### Problem: Search Button Doesn't Expand Input

**Symptoms**: Clicking search button doesn't expand the search input field.

**Solutions**:

1. ‚úÖ Check `searchInput: true` is set in visibility
2. ‚úÖ Verify `[searchInputOpen]` is bound to a signal
3. ‚úÖ Ensure `(searchClick)` handler toggles the state
4. ‚úÖ Confirm `(searchInputOpenChange)` handler syncs state

**Checklist**:

```typescript
// ‚úÖ All required for search expansion:
[visibility] =
  '{ search: true, searchInput: true }'[searchInputOpen] = // Both flags
  'searchInputOpen()'(
    // State binding
    searchClick
  ) =
  'handleSearchClick($event)'(
    // Toggle handler
    searchInputOpenChange
  ) =
    'handleSearchInputOpenChange($event)'; // Sync handler
```

### Problem: Buttons Not Visible

**Symptoms**: Buttons don't appear in navbar.

**Solutions**:

1. ‚úÖ Check `visibility` object includes the button you want
2. ‚úÖ Remember all buttons default to `false` except `user: true`
3. ‚úÖ Set explicit `true` for each button you want visible

**Example**:

```typescript
// ‚ùå WRONG: Buttons won't show
<modus-navbar [userCard]="userCard" />
// Only user button shows (default)

// ‚úÖ CORRECT: Explicit visibility
<modus-navbar
  [userCard]="userCard"
  [visibility]="{ user: true, help: true, search: true, searchInput: true }"
/>
```

### Problem: Menu States Not Syncing

**Symptoms**: Menu state doesn't update when navbar controls it.

**Solutions**:

1. ‚úÖ Always bind both property and event for menu states
2. ‚úÖ Use `(menuOpenChange)` handler to sync state
3. ‚úÖ Check handler parameter type is `boolean`, not `CustomEvent<boolean>`

**Example**:

```typescript
// ‚ùå WRONG: Missing event handler
[mainMenuOpen]="mainMenuOpen()"

// ‚úÖ CORRECT: Two-way binding
[mainMenuOpen]="mainMenuOpen()"
(mainMenuOpenChange)="handleMainMenuOpenChange($event)"

// Handler receives boolean directly (Angular unwraps CustomEvent)
handleMainMenuOpenChange(event: boolean): void {
  this.mainMenuOpen.set(event);
}
```

---

## üìö Key Takeaways

1. **Search Expansion**: Requires both `search: true` AND `searchInput: true` in visibility
2. **State Management**: Always use signals for navbar state
3. **Two-Way Binding**: Bind both property and event for search and menu states
4. **Button Visibility**: Explicitly set all buttons you want visible in `visibility` object
5. **Event Types**: Button clicks = `MouseEvent | KeyboardEvent`, state changes = `boolean`
6. **User Card**: Always required - provide `userCard` input
7. **Event Handling**: Handle all events you need - buttons won't do anything without handlers

---

## üö® Common Mistakes to Avoid

1. ‚ùå Forgetting `searchInput: true` in visibility ‚Üí Search won't expand
2. ‚ùå Only handling `(searchClick)` without `(searchInputOpenChange)` ‚Üí State gets out of sync
3. ‚ùå Only binding `[searchInputOpen]` without handlers ‚Üí Search button won't work
4. ‚ùå Assuming buttons are visible by default ‚Üí Only `user` is visible by default
5. ‚ùå Using wrong event types ‚Üí Button clicks are `MouseEvent | KeyboardEvent`, not `InputEvent`
6. ‚ùå Not providing `userCard` ‚Üí Required input, TypeScript error
7. ‚ùå Missing two-way binding for menu states ‚Üí Menus won't sync properly

---

**Remember**: The navbar component requires explicit configuration for all features. Nothing works by default except the user button!
