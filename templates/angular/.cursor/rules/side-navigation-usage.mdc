# Modus Side Navigation Usage Rules

## Overview

Comprehensive rules for implementing and using the Modus Side Navigation component in Angular applications. Based on validated patterns from Modus 2 Storybook examples and real implementation experience.

## Component Structure

### Recommended Pattern: Navbar Integration with Direct DOM Control

**CRITICAL**: The standard Modus pattern requires **direct DOM manipulation** to properly control side navigation via the navbar's hamburger menu. Angular's two-way binding alone is insufficient.

#### Template Structure

```html
<div class="layout-with-navbar h-[600px] flex flex-col">
  <modus-navbar
    [userCard]="userCardInfo()"
    [visibility]="{ mainMenu: true, user: true }"
    class="navbar"
  />

  <div class="main-content-row flex flex-1 overflow-hidden">
    <modus-side-navigation
      [expanded]="false"
      [collapseOnClickOutside]="true"
      [maxWidth]="'256px'"
      mode="push"
      [targetContent]="'.panel-content'"
      class="side-navigation h-full"
    >
      <modus-menu size="lg">
        <!-- Menu items with slotted icons -->
      </modus-menu>
    </modus-side-navigation>

    <div class="panel-content flex-1 p-6">
      <!-- Main content -->
    </div>
  </div>
</div>
```

#### Component Implementation

```typescript
import { Component, ElementRef, AfterViewInit, signal } from '@angular/core';

@Component({
  // ... component config
})
export class AppComponent implements AfterViewInit {
  readonly navbarMenuExpanded = signal<boolean>(false);
  readonly userCardInfo = signal({
    name: 'John Doe',
    email: 'john.doe@example.com',
    avatarSrc: '',
    avatarAlt: 'User Avatar',
  });

  constructor(private elementRef: ElementRef) {}

  ngAfterViewInit(): void {
    this.setupNavbarSideNavigationIntegration();
  }

  /**
   * CRITICAL: Direct DOM event listening (Storybook pattern)
   */
  private setupNavbarSideNavigationIntegration(): void {
    const container = this.elementRef.nativeElement.querySelector('.layout-with-navbar');

    if (container) {
      // Listen for navbar main menu open change events
      container.addEventListener('mainMenuOpenChange', (event: any) => {
        console.log('Navbar main menu open change event:', event.detail);

        // Find the side navigation element
        const sideNav = container.querySelector('modus-wc-side-navigation');

        if (sideNav) {
          // Directly set the expanded property on the web component
          sideNav.expanded = event.detail;
          console.log('Set side navigation expanded to:', event.detail);

          // Update signal for UI consistency
          this.navbarMenuExpanded.set(event.detail);
        }
      });

      console.log('Navbar-side navigation integration setup complete');
    } else {
      console.error('Could not find .layout-with-navbar container');
    }
  }
}
```

### Standalone Angular Wrapper Component

For cases where you need side navigation without navbar integration:

```html
<modus-side-navigation
  [expanded]="navExpanded()"
  [collapseOnClickOutside]="false"
  [maxWidth]="'256px'"
  mode="overlay"
  (expandedChange)="handleExpandedChange($event)"
>
  <modus-menu size="lg">
    <!-- Menu items here -->
  </modus-menu>
</modus-side-navigation>
```

### Key Properties

| Property                 | Type                  | Description                         | Navbar Integration Value                  |
| ------------------------ | --------------------- | ----------------------------------- | ----------------------------------------- |
| `expanded`               | `boolean`             | Controls expanded/collapsed state   | `[expanded]="false"` (controlled via DOM) |
| `collapseOnClickOutside` | `boolean`             | Auto-collapse when clicking outside | `[collapseOnClickOutside]="true"`         |
| `maxWidth`               | `string`              | Maximum width when expanded         | `[maxWidth]="'256px'"`                    |
| `mode`                   | `'overlay' \| 'push'` | How navigation affects content      | `mode="push"` (recommended)               |
| `targetContent`          | `string`              | CSS selector for content to push    | `[targetContent]="'.panel-content'"`      |

### Critical Implementation Notes

1. **‚ùå DO NOT bind `expanded` to Angular signals** when using navbar integration
2. **‚úÖ Set `expanded="false"`** and let DOM manipulation handle the state
3. **‚úÖ Use `mode="push"`** for proper content shifting behavior
4. **‚úÖ Always include `targetContent`** selector for push mode

### Event Handling

**IMPORTANT**: The Angular wrapper component already extracts `event.detail` from the CustomEvent, so handlers receive the boolean value directly.

```typescript
// ‚úÖ CORRECT: Handler receives boolean directly
handleExpandedChange(isExpanded: boolean): void {
  console.log('Navigation expanded:', isExpanded);
  this.navExpanded.set(isExpanded);
}

// ‚ùå INCORRECT: Don't expect CustomEvent in Angular wrapper
handleExpandedChange(event: CustomEvent<boolean>): void {
  this.navExpanded.set(event.detail); // This will cause TypeScript errors
}
```

## Menu Items with Icons

### ‚úÖ CORRECT: Slotted Icon Pattern

**CRITICAL**: Icons must be provided as **slotted content**, not as attributes.

```html
<modus-menu-item
  label="Dashboard"
  value="dashboard"
  [selected]="selectedItem() === 'dashboard'"
  (itemSelect)="handleItemSelect($event)"
>
  <modus-icon slot="start-icon" name="dashboard" [decorative]="true"></modus-icon>
</modus-menu-item>
```

### ‚ùå INCORRECT: Attribute Pattern (Does Not Work)

```html
<!-- This does NOT work - icons will not appear -->
<modus-menu-item
  label="Dashboard"
  startIcon="dashboard"
  [selected]="selectedItem() === 'dashboard'"
/>
```

### Icon Requirements

1. **Use `slot="start-icon"`** - Required for proper positioning
2. **Set `[decorative]="true"`** - Icons are decorative when paired with text labels
3. **Use valid Modus icon names** - Validate with `npm run lint:icon-names`
4. **Import `ModusIconComponent`** - Required in component imports array

## State Management

### Navbar Integration State

```typescript
export class AppComponent {
  // Navbar main menu state (controls side navigation)
  readonly navbarMenuExpanded = signal<boolean>(false);

  // User card information for navbar
  readonly userCardInfo = signal({
    name: 'John Doe',
    email: 'john.doe@example.com',
    avatarSrc: '',
    avatarAlt: 'User Avatar',
  });

  // Handle navbar main menu state changes
  handleNavbarMenuOpenChange(isOpen: boolean): void {
    console.log('Navbar main menu open change:', isOpen);
    this.navbarMenuExpanded.set(isOpen);
  }

  // Handle side navigation state changes (keeps navbar in sync)
  handleNavbarExpandedChange(isExpanded: boolean): void {
    console.log('Side navigation expanded change:', isExpanded);
    this.navbarMenuExpanded.set(isExpanded);
  }
}
```

### Standalone Signal-Based State

For standalone side navigation without navbar integration:

```typescript
export class SideNavigationComponent {
  // Navigation expanded state
  navExpanded = signal(false);

  // Selected menu item
  selectedItem = signal<string>('dashboard');

  // Toggle navigation
  toggleNavigation(): void {
    this.navExpanded.update((expanded) => !expanded);
  }

  // Handle menu item selection
  handleItemSelect(event: CustomEvent<string>): void {
    this.selectedItem.set(event.detail);
  }
}
```

### Button Integration

```html
<modus-button color="primary" (buttonClick)="handleButtonToggle($event)">
  {{ navExpanded() ? 'Collapse' : 'Expand' }} Navigation
</modus-button>
```

```typescript
handleButtonToggle(event: MouseEvent | KeyboardEvent): void {
  this.toggleNavigation();
}
```

## Layout Patterns

### Container Structure

```html
<div class="relative h-[500px] border-default rounded-lg overflow-hidden">
  <modus-side-navigation
    [expanded]="navExpanded()"
    mode="overlay"
    (expandedChange)="handleExpandedChange($event)"
  >
    <!-- Menu content -->
  </modus-side-navigation>

  <div class="p-6 ml-16">
    <!-- Main content area -->
    <!-- ml-16 accounts for collapsed navigation width (4rem) -->
  </div>
</div>
```

### Mode Differences

#### Overlay Mode

- Navigation overlays content
- Content doesn't shift
- Good for mobile/responsive layouts

```html
<modus-side-navigation mode="overlay"></modus-side-navigation>
```

#### Push Mode

- Navigation pushes content aside
- Requires `targetContent` selector
- Good for desktop layouts

```html
<modus-side-navigation mode="push" [targetContent]="'.main-content'"></modus-side-navigation>
```

## Common Patterns

### Basic Navigation Menu

```html
<modus-side-navigation [expanded]="navExpanded()">
  <modus-menu size="lg">
    <modus-menu-item label="Home" value="home" [selected]="true">
      <modus-icon slot="start-icon" name="home" [decorative]="true"></modus-icon>
    </modus-menu-item>
    <modus-menu-item label="Settings" value="settings">
      <modus-icon slot="start-icon" name="settings" [decorative]="true"></modus-icon>
    </modus-menu-item>
  </modus-menu>
</modus-side-navigation>
```

### Interactive Selection

```typescript
// Component state
selectedItem = signal<string>('home');

// Template
<modus-menu-item
  label="Dashboard"
  value="dashboard"
  [selected]="selectedItem() === 'dashboard'"
  (itemSelect)="handleItemSelect($event)"
>
  <modus-icon slot="start-icon" name="dashboard" [decorative]="true"></modus-icon>
</modus-menu-item>

// Handler
handleItemSelect(event: CustomEvent<string>): void {
  this.selectedItem.set(event.detail);
}
```

## Accessibility

### ARIA Labels

```html
<modus-button color="primary" ariaLabel="Toggle navigation menu" (buttonClick)="toggleNavigation()">
  <modus-icon name="menu" [decorative]="true"></modus-icon>
</modus-button>
```

### Keyboard Navigation

- Side navigation supports keyboard navigation automatically
- Menu items are focusable and selectable via keyboard
- ESC key can close navigation when `collapseOnClickOutside` is true

## Styling

### Width Management

```html
<!-- Default collapsed width: 4rem (64px) -->
<!-- Custom expanded width -->
<modus-side-navigation [maxWidth]="'320px'"></modus-side-navigation>
```

### Content Spacing

```html
<!-- Account for collapsed navigation width -->
<div class="ml-16">
  <!-- 4rem = 64px collapsed width -->
  Main content
</div>
```

## Troubleshooting

### Icons Not Visible

**Problem**: Icons don't appear in menu items
**Solution**: Use slotted content pattern, not `startIcon` attribute

```html
<!-- ‚úÖ Correct -->
<modus-menu-item label="Home">
  <modus-icon slot="start-icon" name="home" [decorative]="true"></modus-icon>
</modus-menu-item>

<!-- ‚ùå Incorrect -->
<modus-menu-item label="Home" startIcon="home" />
```

### Navbar Hamburger Menu Not Working

**Problem**: Hamburger menu only expands but doesn't collapse the side navigation
**Root Cause**: Angular's two-way binding doesn't work properly with Modus navbar events

**‚úÖ Solution**: Use direct DOM manipulation (Storybook pattern)

```typescript
// ‚ùå WRONG: Angular binding approach
<modus-navbar
  [mainMenuOpen]="navbarMenuExpanded()"
  (mainMenuOpenChange)="handleNavbarMenuOpenChange($event)"
/>

// ‚úÖ CORRECT: Direct DOM manipulation approach
<modus-navbar
  [userCard]="userCardInfo()"
  [visibility]="{ mainMenu: true, user: true }"
  class="navbar"
/>

// In ngAfterViewInit():
container.addEventListener('mainMenuOpenChange', (event: any) => {
  const sideNav = container.querySelector('modus-wc-side-navigation');
  if (sideNav) {
    sideNav.expanded = event.detail; // Direct property setting
  }
});
```

### Side Navigation Not Expanding/Collapsing

**Problem**: Navigation doesn't respond to navbar hamburger menu
**Solutions**:

1. **Verify DOM structure**: Ensure `.layout-with-navbar` container exists
2. **Check event listener setup**: Confirm `ngAfterViewInit()` is implemented
3. **Validate selectors**: Ensure `modus-wc-side-navigation` element is found
4. **Console debugging**: Check browser console for setup and event logs

**Debug Steps**:

```typescript
// Add debugging to your setup method
private setupNavbarSideNavigationIntegration(): void {
  const container = this.elementRef.nativeElement.querySelector('.layout-with-navbar');
  console.log('Container found:', !!container);

  if (container) {
    container.addEventListener('mainMenuOpenChange', (event: any) => {
      console.log('Event received:', event.detail);
      const sideNav = container.querySelector('modus-wc-side-navigation');
      console.log('Side nav found:', !!sideNav);
      if (sideNav) {
        console.log('Setting expanded to:', event.detail);
        sideNav.expanded = event.detail;
      }
    });
  }
}
```

### Invalid Icon Names

**Problem**: Some icons don't display
**Solution**: Validate icon names with linting script

```bash
npm run lint:icon-names
```

### Build Errors

**Problem**: Duplicate method definitions or unused imports
**Solutions**:

1. Remove unused component imports (e.g., `ModusButtonComponent` if not used)
2. Check for duplicate method definitions
3. Ensure all imported components are used in template

## Component Imports

Required imports for navbar-integrated side navigation:

```typescript
import { Component, ElementRef, AfterViewInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ModusSideNavigationComponent } from '../modus-side-navigation.component';
import { ModusMenuComponent } from '../modus-menu.component';
import { ModusMenuItemComponent } from '../modus-menu-item.component';
import { ModusIconComponent } from '../modus-icon.component';
import { ModusNavbarComponent } from '../modus-navbar.component';

@Component({
  imports: [
    CommonModule,
    ModusSideNavigationComponent,
    ModusMenuComponent,
    ModusMenuItemComponent,
    ModusIconComponent,
    ModusNavbarComponent,
  ],
})
export class AppComponent implements AfterViewInit {
  constructor(private elementRef: ElementRef) {}

  ngAfterViewInit(): void {
    this.setupNavbarSideNavigationIntegration();
  }
}
```

## Best Practices

### Navbar Integration (Recommended)

1. **‚úÖ Use direct DOM manipulation** - Follow Storybook pattern for navbar control
2. **‚úÖ Implement `AfterViewInit`** - Set up event listeners after view initialization
3. **‚úÖ Use `ElementRef`** - Access DOM elements for event binding
4. **‚úÖ Set `expanded="false"`** - Let DOM manipulation control the state
5. **‚úÖ Use `mode="push"`** - Provides better UX than overlay mode
6. **‚úÖ Include `targetContent`** - Required for push mode functionality

### Icon Implementation

1. **‚úÖ Always use slotted icons** - Never use `startIcon` attribute
2. **‚úÖ Set `[decorative]="true"`** - Icons are decorative when paired with text
3. **‚úÖ Validate icon names** - Use `npm run lint:icon-names`
4. **‚úÖ Import `ModusIconComponent`** - Required for slotted content

### Layout and Styling

1. **‚úÖ Use semantic CSS classes** - `.layout-with-navbar`, `.main-content-row`, `.panel-content`
2. **‚úÖ Account for collapsed width** - Use `ml-16` for content spacing (4rem = 64px)
3. **‚úÖ Set proper container height** - Use `h-[600px]` or appropriate height
4. **‚úÖ Enable overflow handling** - Use `overflow-hidden` on containers

### Debugging and Maintenance

1. **‚úÖ Add console logging** - Debug event flow and DOM queries
2. **‚úÖ Handle error cases** - Check for missing DOM elements
3. **‚úÖ Remove unused imports** - Avoid build warnings
4. **‚úÖ Test expand/collapse** - Verify hamburger menu works both ways

## Complete Working Example

Reference the side navigation demo page (`/demos/side-navigation`) for a complete implementation that demonstrates:

- ‚úÖ **Navbar integration with working hamburger menu**
- ‚úÖ **Icons visible in collapsed and expanded states**
- ‚úÖ **Push mode with proper content shifting**
- ‚úÖ **Direct DOM manipulation pattern**
- ‚úÖ **Console logging for debugging**
- ‚úÖ **Proper error handling**

## Critical Success Factors

### üéØ The Three Essential Elements

1. **Slotted Icon Content**: `<modus-icon slot="start-icon" name="icon-name" [decorative]="true">`
2. **Direct DOM Control**: Event listeners in `ngAfterViewInit()` with `querySelector()`
3. **Proper Layout Structure**: `.layout-with-navbar` ‚Üí `.main-content-row` ‚Üí components

### ‚ö†Ô∏è Common Pitfalls to Avoid

1. **‚ùå Using `startIcon` attribute** - Icons won't appear
2. **‚ùå Angular two-way binding for navbar** - Toggle won't work properly
3. **‚ùå Missing `AfterViewInit`** - Event listeners won't be set up
4. **‚ùå Wrong CSS selectors** - DOM queries will fail
5. **‚ùå Binding `expanded` to signals** - Conflicts with DOM manipulation

---

**Key Takeaway**: Successful Modus side navigation requires **three critical patterns**: slotted icon content, direct DOM manipulation for navbar integration, and proper layout structure. Angular's reactive patterns alone are insufficient for full functionality.

## CSS Classes for Sub-Menus

### Reusable CSS Classes (in `src/styles.css`)

All side navigation styling has been moved to the main CSS file for reusability. Use these prefixed classes:

| Class Name | Purpose | Usage |
|------------|---------|-------|
| `.side-nav-children-container` | Sub-menu container with transitions | Applied to `<li>` containing sub-items |
| `.side-nav-collapse-icon` | Icon sizing and padding | Applied to all icons in menu items |
| `.side-nav-dropdown-menu` | Menu text with ellipsis overflow | Applied to menu item text containers |
| `.side-nav-flex-row` | Flex layout for menu items | Applied to clickable menu item containers |
| `.side-nav-hidden` | Hidden state utility | Toggled on/off for sub-menu visibility |
| `.side-nav-justify-end` | Right-aligned content | Applied to containers with right-aligned icons |
| `.side-nav-menu-width` | Full width menu | Applied to `modus-menu` via `customClass` |
| `.side-nav-nested-row` | First-level nested indentation | Applied to sub-menu items |
| `.side-nav-deeply-nested-row` | Second-level nested indentation | Applied to deeply nested items |
| `.side-nav-submenu-item` | Sub-menu item styling | Applied to clickable sub-menu items |
| `.side-nav-menu-item-container` | Menu item with border | Applied to menu item containers |
| `.side-nav-nested-submenu` | Nested sub-menu indentation | Applied to nested sub-menu containers |
| `.side-nav-icon-left` | Left icon positioning | Applied to left-positioned icons |
| `.side-nav-dropdown-toggle` | Dropdown toggle icon animation | Applied to expand/collapse icons |

### Example Usage

```html
<modus-menu ariaLabel="Custom menu" customClass="side-nav-menu-width">
  <li>
    <div class="side-nav-flex-row" (click)="handleCollapseToggle($event)">
      <modus-icon name="bar_graph" [decorative]="true" class="side-nav-collapse-icon side-nav-icon-left"></modus-icon>
      <div class="side-nav-dropdown-menu">Charts</div>
      <div class="side-nav-justify-end">
        <modus-icon name="expand_more" [decorative]="true" class="side-nav-collapse-icon side-nav-dropdown-toggle"></modus-icon>
      </div>
    </div>
  </li>
  <li class="side-nav-children-container side-nav-hidden" aria-hidden="true">
    <ul>
      <li>
        <div class="side-nav-flex-row side-nav-nested-row" (click)="selectMenuItem('bar-chart')">
          <div>Bar Chart</div>
        </div>
      </li>
    </ul>
  </li>
</modus-menu>
```

### JavaScript Class References

When using direct DOM manipulation, reference the new class names:

```typescript
// Find dropdown toggle icons
const iconEl = clickedEl.querySelector('.side-nav-dropdown-toggle');

// Find children containers
const childContainer = parentLi.nextElementSibling?.classList.contains('side-nav-children-container');

// Toggle visibility
childContainer.classList.toggle('side-nav-hidden');

// Reset all sub-menus
const childrenContainers = container.querySelectorAll('.side-nav-children-container');
childrenContainers.forEach((container) => {
  container.classList.add('side-nav-hidden');
});

// Reset all toggle icons
const collapseIcons = container.querySelectorAll('.side-nav-dropdown-toggle');
```

---

**Remember**: All CSS classes are now globally available in `src/styles.css` for reuse across the application. The side navigation component requires careful integration with the navbar component using direct DOM manipulation following the Storybook pattern.
